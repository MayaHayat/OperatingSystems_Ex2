void handle_get_request(int client_socket, const char *full_path) {
    FILE *file = fopen(full_path, "rb");
    if (file == NULL) {
        // File not found
        send_response(client_socket, "404 Not Found\r\n\r\n");
    } else {
        // Read and send the file content
        send_response(client_socket, "200 OK\r\n");

        char file_buffer[MAX_BUFFER_SIZE];
        size_t bytes_read;

        while ((bytes_read = fread(file_buffer, 1, sizeof(file_buffer), file)) > 0) {
            send(client_socket, file_buffer, bytes_read, 0);
            printf("sending %s",file_buffer);
        }
        send_response(client_socket, "\r\n\r\n");

        fclose(file);
    }
}

void handle_post_request(int client_socket, const char *full_path) {
    // Attempt to lock the file for writing
    struct flock lock;
    lock.l_type = F_WRLCK;  // Exclusive write lock
    lock.l_whence = SEEK_SET;
    lock.l_start = 0;
    lock.l_len = 0;

    int file_fd = open(full_path, O_WRONLY | O_CREAT | O_TRUNC, 0666);
    if (file_fd < 0) {
        perror("Error opening file");
        send_response(client_socket, "500 INTERNAL ERROR\r\n\r\n");
        close(client_socket);
        exit(EXIT_FAILURE);
    }

    // Attempt to acquire the lock
    if (fcntl(file_fd, F_SETLK, &lock) == -1) {
        perror("Error acquiring lock");
        close(file_fd);
        send_response(client_socket, "500 INTERNAL ERROR\r\n\r\n");
        close(client_socket);
        exit(EXIT_FAILURE);
    }

    // Continue tokenizing and writing to file
    char buffer[MAX_BUFFER_SIZE];
    ssize_t bytes_received;

    while (1) {
        bytes_received = recv(client_socket, buffer, sizeof(buffer), 0);
        if (bytes_received <= 0) {
            break;
        }
        if (write(file_fd, buffer, bytes_received) < 0) {
            perror("Error writing to file");
            close(file_fd);
            close(client_socket);
            exit(EXIT_FAILURE);
        }
    }

    printf("Finished writing to file\n");
    fflush(stdout);

    // Release the lock
    lock.l_type = F_UNLCK;
    if (fcntl(file_fd, F_SETLK, &lock) == -1) {
        perror("Error releasing lock");
        close(file_fd);
        close(client_socket);
        exit(EXIT_FAILURE);
    }

    close(file_fd);

    // Send response to the client
    send_response(client_socket, "200 OK\r\n\r\n");
}

void handle_client(int client_socket, char *root_dir) {
    char buffer[MAX_BUFFER_SIZE];
    ssize_t bytes_received;

    usleep(70000);

    // Receive the request from the client
    bytes_received = recv(client_socket, buffer, sizeof(buffer), 0);
    if (bytes_received < 0) {
        perror("Error receiving request");
        close(client_socket);
        exit(EXIT_FAILURE);
    }

    printf("buffer contains <<<<%.*s>>>>\n", (int)bytes_received, buffer);


    // Tokenize the request based on "\r\n"
    char *token;
    char *method, *path;
    token = strtok(buffer, "\r\n");


    // Extract method and path
    if (token != NULL) {
        sscanf(token, "%ms %ms", &method, &path);
    } else {
        // Handle invalid request
        send_response(client_socket, "400 Bad Request\r\n\r\n");
        close(client_socket);
        exit(EXIT_FAILURE);
    }

    char full_path[MAX_PATH_SIZE];
    snprintf(full_path, sizeof(full_path), "%s%s", root_dir, path);

    if (strcmp(method, "GET") == 0) {
        handle_get_request(client_socket, full_path);
    } else if (strcmp(method, "POST") == 0) {
        handle_post_request(client_socket, full_path);
    }

    // Cleanup
    free(method);
    free(path);
    close(client_socket);
    exit(EXIT_SUCCESS);
}
